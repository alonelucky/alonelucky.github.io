{
    "version": "https://jsonfeed.org/version/1",
    "title": "小码农博客 • All posts by \"nodejs\" category",
    "description": null,
    "home_page_url": "http://qiubo.ink",
    "items": [
        {
            "id": "http://qiubo.ink/2023/03/16/Nodejs-v19-x-%E6%94%AF%E6%8C%81%E6%89%93%E5%8C%85%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%8D%95%E6%96%87%E4%BB%B6/",
            "url": "http://qiubo.ink/2023/03/16/Nodejs-v19-x-%E6%94%AF%E6%8C%81%E6%89%93%E5%8C%85%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%8D%95%E6%96%87%E4%BB%B6/",
            "title": "Nodejs v19.x 支持打包可执行单文件",
            "date_published": "2023-03-16T10:45:34.000Z",
            "content_html": "<p>官方文档：<a href=\"https://nodejs.org/dist/latest-v19.x/docs/api/single-executable-applications.html\">Single executable applications</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"特性介绍：\"><a href=\"#特性介绍：\" class=\"headerlink\" title=\"特性介绍：\"></a>特性介绍：</h2><p>有的语言原生工具链就支持打包单独可执行文件，如：<code>go build</code> <code>dart complite exe</code></p>\n<p>有的有社区解决方案，如：<code>PyInstaller</code> nodejs社区的：<a href=\"https://github.com/vercel/ncc\"><code>ncc</code></a>&#x2F;<a href=\"https://github.com/vercel/pkg\"><code>pkg</code></a></p>\n<p>如今，nodejs 在 v19.x 引入实验性单独可执行文件，提供了官方打包工具链。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>基础环境：安装 Nodejs v19.x 及以上，只有最新版本支持</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  1.创建 js 文件</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;console.log(`Hello, $&#123;process.argv[2]&#125;!`);&#x27;</span> &gt; hello.js</span><br><span class=\"line\"><span class=\"comment\"># 2. 复制当前版本的 node 二进制文件到当前目录，并重命名为想要的二进制名称</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> $(<span class=\"built_in\">which</span> node) hello</span><br><span class=\"line\"><span class=\"comment\"># 3. 进行打包</span></span><br><span class=\"line\">npx postject hello NODE_JS_CODE hello.js \\</span><br><span class=\"line\">    --sentinel-fuse NODE_JS_FUSE_fce680ab2cc467b6e072b8b5df1996b2 \\</span><br><span class=\"line\">    --macho-segment-name NODE_JS <span class=\"comment\"># 最后一行只有 macos 需要</span></span><br><span class=\"line\"><span class=\"comment\"># 4. 运行可执行文件</span></span><br><span class=\"line\">./hello world</span><br><span class=\"line\">Hello, world!</span><br></pre></td></tr></table></figure>\n<p>以上是官方示例，通过第三步可以看出，实际上是 <a href=\"https://github.com/nodejs/postject\"><code>postject</code></a> 在起作用, 可以自行安装使用</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>目前只能打包一个 js 文件， 与 pkg 是打包一整个文件夹不同，是否就不能应用了呢？顺势可以想到把整个项目打包为单独的 js 文件不就解决了这个问题了吗？这便是 ncc（Compile a Node.js project into a single file. Supports TypeScript, binary addons, dynamic requires.）, 尝试一下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> singleapp</span><br><span class=\"line\"><span class=\"comment\"># 初始化项目</span></span><br><span class=\"line\">npm init</span><br><span class=\"line\"><span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\">npm i -S express</span><br><span class=\"line\"><span class=\"comment\"># ...创建多文件文件夹及相互依赖</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 ncc 打包单文件， dist/index.js</span></span><br><span class=\"line\">ncc build app.js -o dist</span><br><span class=\"line\"><span class=\"comment\"># 复制当前版本的 node 二进制文件到当前目录，并重命名为想要的二进制名称</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> $(<span class=\"built_in\">which</span> node) singleapp</span><br><span class=\"line\"><span class=\"comment\"># 3. 进行打包</span></span><br><span class=\"line\">npx postject singleapp NODE_JS_CODE dist/index.js \\</span><br><span class=\"line\">    --sentinel-fuse NODE_JS_FUSE_fce680ab2cc467b6e072b8b5df1996b2 \\</span><br><span class=\"line\">    --macho-segment-name NODE_JS <span class=\"comment\"># 最后一行只有 macos 需要</span></span><br><span class=\"line\"><span class=\"comment\"># 4. 运行可执行文件</span></span><br><span class=\"line\">./singleapp</span><br><span class=\"line\">server is running at 127.0.0.1:3000</span><br></pre></td></tr></table></figure>\n<p>由于打包了 nodevm 所以生成的二进制文件会比较大，单文件打包结果是 83Mb，但是 node 二进制原包是 90MB，应该是有压缩，可以使用 <code>upx</code> 进行二进制加壳压缩。</p>\n<h2 id=\"结言\"><a href=\"#结言\" class=\"headerlink\" title=\"结言\"></a>结言</h2><p>Nodejs 多年呼吁的打包功能官方终于开始启动了，还有一些瑕疵，而且实验性功能改动到后边会比较大，可以多多跟进，目前的官方讨论区在</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/single-executable/discussions\">讨论区</a></li>\n<li><a href=\"https://github.com/nodejs/node/issues/43432\">Initiative: Single Executable Application #43432</a></li>\n</ul>\n<p>以前社区百花齐放提供了很多的打包方案，<code>pkg</code>, <code>jsexe</code>, <code>ncc</code>, <code>bytecode</code> 等等，其实 <code>webpack</code> 这些也是可以支持后端项目打包的，也可以打包合并为单独 js 文件，复用 js 打包生态，源码混淆，sourcemap 支持等等</p>\n",
            "tags": [
                "nodejs"
            ]
        },
        {
            "id": "http://qiubo.ink/2018/09/14/%E4%BD%BF%E7%94%A8nodejs%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/",
            "url": "http://qiubo.ink/2018/09/14/%E4%BD%BF%E7%94%A8nodejs%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/",
            "title": "使用nodejs创建自己的自动化工具",
            "date_published": "2018-09-14T12:00:07.000Z",
            "content_html": "<p>nodejs能方便的进行前端的文件压缩结合等等,自动化操作,但是经常使用的我们,是不是也能方便的建立自己的自动化部署工具呢?比如:经常从头建立的文件夹模式,千篇一律的index.html等等</p>\n<span id=\"more\"></span>\n<h3 id=\"开发步骤\"><a href=\"#开发步骤\" class=\"headerlink\" title=\"开发步骤\"></a>开发步骤</h3><h6 id=\"1-安装nodejs环境\"><a href=\"#1-安装nodejs环境\" class=\"headerlink\" title=\"1. 安装nodejs环境\"></a>1. 安装nodejs环境</h6><p>从<a href=\"https://nodejs.org/\">官网</a>或<a href=\"https://nodejs.cn/\">中文官网</a>下载nodejs的安装包,参照网上的安装方法安装好nodejs环境,</p>\n<p>此处不是介绍nodejs,,因此不介绍如何安装</p>\n<h6 id=\"2-创建项目\"><a href=\"#2-创建项目\" class=\"headerlink\" title=\"2. 创建项目\"></a>2. 创建项目</h6><p>创建项目文件夹,进入并执行npm init,如下图 <a href=\"https://github.com/xiaqiubo/nodejs-traning/blob/master/course/imgs/20171031/01.png\"><img src=\"https://github.com/xiaqiubo/nodejs-traning/raw/master/course/imgs/20171031/01.png\"></a></p>\n<p>如下信息是需要填写的 :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package name: (jiaocheng)</span><br><span class=\"line\">version: (1.0.0) 0.1.0</span><br><span class=\"line\">description: 自制自动化工具</span><br><span class=\"line\">entry point: (index.js)</span><br><span class=\"line\"><span class=\"built_in\">test</span> <span class=\"built_in\">command</span>:</span><br><span class=\"line\">git repository:</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: xiaoxia</span><br><span class=\"line\">license: (ISC)</span><br></pre></td></tr></table></figure>\n<p>在最后生成的package.json中增加一项</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"string\">&quot;bin&quot;</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;jiaocheng&quot;</span>:<span class=\"string\">&quot;index.js&quot;</span>\t</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bin为可执行命令,<code>jiaocheng</code>为执行命令,<code>index.js</code>为命令执行文件入口</p>\n<p>然后执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"built_in\">link</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/xiaqiubo/nodejs-traning/blob/master/course/imgs/20171031/04.png\"><img src=\"https://github.com/xiaqiubo/nodejs-traning/raw/master/course/imgs/20171031/04.png\"></a>此命令向系统增加一条软连接(可以理解为快捷方式)引用,方便使用当前项目的 bin 命令(便于本地调试)</p>\n<h6 id=\"3-创建index-js-入口文件\"><a href=\"#3-创建index-js-入口文件\" class=\"headerlink\" title=\"3. 创建index.js,入口文件\"></a>3. 创建index.js,入口文件</h6><p>一定要在顶部加上 <code>#!/usr/bin/env node</code> 声明,该文件使用环境变量 node 调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello world!&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>如图 :</p>\n<p><a href=\"https://github.com/xiaqiubo/nodejs-traning/blob/master/course/imgs/20171031/02.png\"><img src=\"https://github.com/xiaqiubo/nodejs-traning/raw/master/course/imgs/20171031/02.png\"></a></p>\n<p>然后打开cmd窗口,输入 <code>jiaocheng</code> 回车,输出如下图</p>\n<p><a href=\"https://github.com/xiaqiubo/nodejs-traning/blob/master/course/imgs/20171031/03.png\"><img src=\"https://github.com/xiaqiubo/nodejs-traning/raw/master/course/imgs/20171031/03.png\"></a></p>\n<h6 id=\"4-项目依赖选择\"><a href=\"#4-项目依赖选择\" class=\"headerlink\" title=\"4. 项目依赖选择\"></a>4. 项目依赖选择</h6><p>此时已经基本成型了,你可以执行命令做一些你想做的事情,也可以自己处理一些 process 变量</p>\n<p>常用的nodejs自带 process属性</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.argv\t\t<span class=\"comment\"># \t获取传入参数</span></span><br><span class=\"line\">process.cwd()\t\t<span class=\"comment\">#\t获取当前命令执行所在目录</span></span><br><span class=\"line\">process.env\t\t\t<span class=\"comment\">#\t获取当前系统用户的环境变量</span></span><br><span class=\"line\">process.pid\t\t\t<span class=\"comment\">#\t获取当前进程的pid</span></span><br><span class=\"line\">process.platform\t<span class=\"comment\">#\t获取当前运行的平台(系统)</span></span><br><span class=\"line\">process.stdin\t\t<span class=\"comment\">#\t输入</span></span><br><span class=\"line\">process.stdout\t\t<span class=\"comment\"># \t输出</span></span><br><span class=\"line\">process.versions\t<span class=\"comment\">#\t当前nodejs环境所有版本信息</span></span><br></pre></td></tr></table></figure>\n<p>常用模块推荐 (持续更新中):</p>\n<p>commander \t#\t作者Tj用于自动生成命令参数获取,单包无依赖</p>\n<p>commander 链接及使用看<a href=\"https://npmjs.com/package/commander\">npmjs</a>介绍或者<a href=\"https://github.com/tj/commander.js\">github</a>介绍即可</p>\n<h3 id=\"模块发布\"><a href=\"#模块发布\" class=\"headerlink\" title=\"模块发布\"></a>模块发布</h3><hr>\n<h6 id=\"5-注册npmjs账号\"><a href=\"#5-注册npmjs账号\" class=\"headerlink\" title=\"5. 注册npmjs账号\"></a>5. 注册npmjs账号</h6><p>到<a href=\"https://www.npmjs.com/signup\">npmjs官网注册</a>一个npmjs账号,用于发布自己的模块</p>\n<h6 id=\"6-登录npmjs并发布自己的模块\"><a href=\"#6-登录npmjs并发布自己的模块\" class=\"headerlink\" title=\"6. 登录npmjs并发布自己的模块\"></a>6. 登录npmjs并发布自己的模块</h6><p>模块按照上面的步骤开发,注册过账号后就可以发布自己的模块了,此处的登录不是在网页上的登录,而是在命令行下执行:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm login</span><br></pre></td></tr></table></figure>\n<p>会提示输入账号密码,输入注册的账号密码即可</p>\n<p>登录成功后,到项目目录下,执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n<p>片刻后便会执行成功</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li>部分开发者习惯将npm镜像修改为国内的cnpm.js淘宝镜像,在发布包的时候记得将镜像切换回官方 <a href=\"https://registry.npmjs.org/\">https://registry.npmjs.org/</a></li>\n</ol>\n<p>可以执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config list</span><br></pre></td></tr></table></figure>\n<p>查看是否替换</p>\n<ol start=\"2\">\n<li>发布的npm模块名称必须为全小写,不支持大小驼峰名称,一般修改为英文中横线</li>\n</ol>\n",
            "tags": [
                "nodejs",
                "cli"
            ]
        },
        {
            "id": "http://qiubo.ink/2018/09/14/nodejs%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E7%9A%84jwt/",
            "url": "http://qiubo.ink/2018/09/14/nodejs%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E7%9A%84jwt/",
            "title": "nodejs实现基础的jwt",
            "date_published": "2018-09-14T11:57:03.000Z",
            "content_html": "<p>手动实现 <code>JSON Web Token</code> 了解 token 验证基本原理</p>\n<span id=\"more\"></span>\n<p>使用模块,nodejs原生模块<br>Crypto</p>\n<h3 id=\"1-实现机制\"><a href=\"#1-实现机制\" class=\"headerlink\" title=\"1. 实现机制\"></a>1. 实现机制</h3><p>JSON Web Token 由三部分组成，头部（Header）、载荷（Payload）与签名（Signature），并由 <code>.</code> 英文点拼接。</p>\n<h6 id=\"1-Header\"><a href=\"#1-Header\" class=\"headerlink\" title=\"1. Header\"></a>1. Header</h6><p>生成jwt头部,声明其类型以及签名所用的算法等的JSON格式,并将其进行base64转码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let jwtHeader = &#123;</span><br><span class=\"line\">    typ:&#x27;JWT&#x27;,</span><br><span class=\"line\">    alg:&#x27;SHA256&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jwtHeader = Buffer.from(JSON.stringify(jwtHeader)).toString(&#x27;base64&#x27;);</span><br><span class=\"line\">// base64</span><br></pre></td></tr></table></figure>\n<h6 id=\"2-Payload\"><a href=\"#2-Payload\" class=\"headerlink\" title=\"2. Payload\"></a>2. Payload</h6><p>生成jwt载荷部分,并将其进行base64转码</p>\n<ul>\n<li><p>iss: 该JWT的签发者，是否使用是可选的；</p>\n</li>\n<li><p>sub: 该JWT所面向的用户，是否使用是可选的；</p>\n</li>\n<li><p>aud: 接收该JWT的一方，是否使用是可选的；</p>\n</li>\n<li><p>exp(expires): 什么时候过期，这里是一个Unix时间戳，是否使用是可选的；</p>\n</li>\n<li><p>iat(issued at): 在什么时候签发的(UNIX时间)，是否使用是可选的；</p>\n</li>\n<li><p>nbf (Not Before)：如果当前时间在nbf里的时间之前，则Token不被接受；一般都会留一些余地，比如几分钟；，是否使用是可选的；</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let jwtPayload = &#123;</span><br><span class=\"line\">    data:&#123;</span><br><span class=\"line\">        userId: 123456</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    exp: &#x27;2018-08-01&#x27;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jwtPayload = Buffer.from(JSON.stringify(jwtPayload)).toString(&#x27;base64&#x27;);</span><br></pre></td></tr></table></figure>\n<h6 id=\"3-Signature\"><a href=\"#3-Signature\" class=\"headerlink\" title=\"3. Signature\"></a>3. Signature</h6><p>将上面的两个编码后的字符串都用句号.连接在一起（头部在前）,并使用sha256及secret对其进行签名处理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const crypto = require(&#x27;crypto&#x27;);</span><br><span class=\"line\">let jwtStr = jwtHeader + &#x27;.&#x27; + jwtPayload;</span><br><span class=\"line\">let jwtSignature = crypto.createHmac(&#x27;sha256&#x27;,&#x27;my secret&#x27;).update(jwtStr).digest(&#x27;base64&#x27;);</span><br></pre></td></tr></table></figure>\n<h6 id=\"4-jwt\"><a href=\"#4-jwt\" class=\"headerlink\" title=\"4. jwt\"></a>4. jwt</h6><p>将三个部分连接即组成了完整的jwt</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let jwtToken = jwtHeader + &#x27;.&#x27; + jwtPayload + &#x27;.&#x27; + jwtSignature;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-jwt解析\"><a href=\"#2-jwt解析\" class=\"headerlink\" title=\"2. jwt解析\"></a>2. jwt解析</h3><p>处理生成 <code>jwt</code> 是需要使用的，生成如上，解析自然也就比较简单</p>\n<h6 id=\"1-校验签名\"><a href=\"#1-校验签名\" class=\"headerlink\" title=\"1. 校验签名\"></a>1. 校验签名</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 拆分jwt</span><br><span class=\"line\">let jwtArr = jwtToken.split(&#x27;.&#x27;);</span><br><span class=\"line\">// 根据头部和载荷验证签名是否匹配</span><br><span class=\"line\">let checkToken = crypto.createHmac(&#x27;sha256&#x27;,&#x27;my secret&#x27;).update(jwtArr[0]+&#x27;.&#x27;+jwtArr[1]).digest(&#x27;base64&#x27;);</span><br><span class=\"line\">checkToken ?= jwtArr[2]</span><br></pre></td></tr></table></figure>\n<h6 id=\"2-解析数据\"><a href=\"#2-解析数据\" class=\"headerlink\" title=\"2. 解析数据\"></a>2. 解析数据</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//　校验签名通过，解析载荷的base64数据</span><br><span class=\"line\">let jwtPayload = JSON.parse(Buffer.from(jwtArr[1],&#x27;base64&#x27;).toString())</span><br></pre></td></tr></table></figure>",
            "tags": [
                "josn web token",
                "jwt"
            ]
        },
        {
            "id": "http://qiubo.ink/2017/09/14/Verdaccio%E6%90%AD%E5%BB%BAnpm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/",
            "url": "http://qiubo.ink/2017/09/14/Verdaccio%E6%90%AD%E5%BB%BAnpm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/",
            "title": "Verdaccio 搭建npm私有仓库",
            "date_published": "2017-09-14T11:56:01.000Z",
            "content_html": "<p>使用Nodejs的过程中未免会遇到公司项目私有化开发，此时需要一些私有模块的发布和使用，<code>npmjs</code>的私有仓库是付费的功能,<code>cnpm</code>本地搭建又偏重，<code>verdaccio</code>项目刚好满足，轻量私有部署简单</p>\n<span id=\"more\"></span>\n\n<p>由于<code>sinopia</code>项目不再维护,故选取fork项目<code>verdaccio</code>进行搭建,使用方法一样,仅仅将<code>sinopia</code>换为<code>verdaccio</code></p>\n<p>环境依赖</p>\n<p>python 2.7.x<br>node-gyp</p>\n<h3 id=\"1-安装verdaccio\"><a href=\"#1-安装verdaccio\" class=\"headerlink\" title=\"1. 安装verdaccio\"></a>1. 安装verdaccio</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g verdaccio</span><br><span class=\"line\"></span><br><span class=\"line\">配置文件 ~/.config/verdaccio/config.yaml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 存放位置</span></span><br><span class=\"line\">storage: ./npmdata</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 认证</span></span><br><span class=\"line\">auth:</span><br><span class=\"line\">\thtpasswd:</span><br><span class=\"line\">\t\tfile:./authpasswd</span><br><span class=\"line\">\t\tmax_users:10</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 抓取镜像源</span></span><br><span class=\"line\">uplinks</span><br><span class=\"line\">\tnpmjs:</span><br><span class=\"line\">\t\turl:http://registry.npm.taobao.org/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># package</span></span><br><span class=\"line\">packages:</span><br><span class=\"line\">\t<span class=\"string\">&quot;@*/*&quot;</span>:</span><br><span class=\"line\">\t\taccess:<span class=\"variable\">$all</span></span><br><span class=\"line\">\t\tpublish:<span class=\"variable\">$authenticated</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;*&quot;</span>:</span><br><span class=\"line\">\t\taccess:<span class=\"variable\">$all</span></span><br><span class=\"line\">\t\tpublish:<span class=\"variable\">$authenticated</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 日志</span></span><br><span class=\"line\">logs:</span><br><span class=\"line\">\t- &#123;<span class=\"built_in\">type</span>:stdout,format:pretty,level:http,path:./npm.log&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 监听端口(默认没有这个选项监听4873端口)</span></span><br><span class=\"line\">listen:\t0.0.0.0:4433</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-启动项目\"><a href=\"#2-启动项目\" class=\"headerlink\" title=\"2. 启动项目\"></a>2. 启动项目</h3><ol>\n<li>默认启动<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">verdaccio</span><br><span class=\"line\"><span class=\"comment\"># 默认加载 ~/.config/verdaccio/config.yaml</span></span><br><span class=\"line\"><span class=\"comment\"># 默认监听</span></span><br><span class=\"line\"><span class=\"comment\"># 默认存储位置 ~/.config/verdaccio/storage/</span></span><br><span class=\"line\"><span class=\"comment\"># 默认账号密码存放位置 ~/.config/verdaccio/htpasswd</span></span><br></pre></td></tr></table></figure></li>\n<li>终端命令启动</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">verdaccio -l 端口 -c 配置文件位置</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>pm2进程守护</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start `<span class=\"built_in\">which</span> verdaccio` --name <span class=\"string\">&quot;local_npm&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-项目使用\"><a href=\"#3-项目使用\" class=\"headerlink\" title=\"3. 项目使用\"></a>3. 项目使用</h3><ol>\n<li>修改源<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"built_in\">set</span> registry http://0.0.0.0:4433</span><br></pre></td></tr></table></figure></li>\n<li>增加用户</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm adduser --registry http://0.0.0.0:4433</span><br><span class=\"line\">Username:</span><br><span class=\"line\">Passwd:</span><br><span class=\"line\">Emial:</span><br></pre></td></tr></table></figure>\n<ol>\n<li>发布包 和发布到npm仓库一样,登录,发布</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm login</span><br><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n<ol>\n<li>安装包</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @xxx/yyy</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-注\"><a href=\"#4-注\" class=\"headerlink\" title=\"4. 注\"></a>4. 注</h3><p>使用 <code>nrm</code> 管理源 使用 nrm 增加源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nrm add nl http://0.0.0.0:4433</span><br></pre></td></tr></table></figure>\n<p>使用 nrm 切换源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nrm use nl</span><br></pre></td></tr></table></figure>\n<p>浏览 nrm 源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nrm ls</span><br></pre></td></tr></table></figure>",
            "tags": [
                "npm"
            ]
        },
        {
            "id": "http://qiubo.ink/2017/05/12/%E5%88%A9%E7%94%A8fs%E9%81%8D%E5%8E%86%E5%9B%BE%E7%89%87,%E4%BD%BF%E7%94%A8tinify%E5%8E%8B%E7%BC%A9/",
            "url": "http://qiubo.ink/2017/05/12/%E5%88%A9%E7%94%A8fs%E9%81%8D%E5%8E%86%E5%9B%BE%E7%89%87,%E4%BD%BF%E7%94%A8tinify%E5%8E%8B%E7%BC%A9/",
            "title": "利用fs遍历图片,使用tinify压缩",
            "date_published": "2017-05-12T17:47:57.000Z",
            "content_html": "<p>gulp前端自动化中有压缩图片的工具gulp-imagemin等,但是压缩效果并不很理想,之前发现的tinypng.com网站提供许多压缩接口(puby,java,python,php,nodejs等)和插件(photo,wordpress等),当然这个是付费的.免费配额为500张图片&#x2F;每月。个人觉得轻度使用是足够的。</p>\n<span id=\"more\"></span>\n\n<h4 id=\"1-官方站点提供了常规调用方法\"><a href=\"#1-官方站点提供了常规调用方法\" class=\"headerlink\" title=\"1. 官方站点提供了常规调用方法\"></a>1. 官方站点提供了常规调用方法</h4><p>安装:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save tinify</span><br></pre></td></tr></table></figure>\n<p>调用:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var tinify = require(&#x27;tinify&#x27;);</span><br><span class=\"line\">tinify.key=&#x27;your key &#x27;;</span><br></pre></td></tr></table></figure>\n<p>这个是提供邮箱即可获得秘钥,在此我就不贴出来了,秘钥链接:<a href=\"https://tinypng.com/developers\">https://tinypng.com/developers</a></p>\n<p>收到邮件后,点击即可获取(可能在垃圾邮件中)</p>\n<p>压缩操作:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var source = tinify.fromFile(&quot;unoptimized.jpg&quot;);</span><br><span class=\"line\">source.toFile(&quot;optimized.jpg&quot;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-利用fs获得文件数组\"><a href=\"#2-利用fs获得文件数组\" class=\"headerlink\" title=\"2. 利用fs获得文件数组\"></a>2. 利用fs获得文件数组</h4><p>但是,只提供一次操作一个文件,比较繁复.于是利用node自带的fs文件系统模块,获取到文件,并遍历操作</p>\n<p>fs.readdir() 异步获取<br>fs.readdirSync() 同步获取<br>该函数传参数为文件夹名,返回值均为文件名数组,因为在本地操作,而且是需要获取到图片后才操作,所以选择同步获取</p>\n<p>代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fileNameArr = fs.readdirSync(&#x27;img&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">fileNameArr.forEach(function(fileName)&#123;</span><br><span class=\"line\">    source = tinify.fromFile(&quot;img/&quot;+fileName);</span><br><span class=\"line\">    source.toFile(&quot;a/&quot;+fileName);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样就好了.</p>\n",
            "tags": []
        },
        {
            "id": "http://qiubo.ink/2016/12/26/linux%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85nodejs/",
            "url": "http://qiubo.ink/2016/12/26/linux%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85nodejs/",
            "title": "linux下配置安装nodejs",
            "date_published": "2016-12-26T11:29:20.000Z",
            "content_html": "<h2 id=\"linux下配置安装nodejs\"><a href=\"#linux下配置安装nodejs\" class=\"headerlink\" title=\"linux下配置安装nodejs\"></a>linux下配置安装nodejs</h2><p>（非广告）virmach 美国VPS主机 <code>7.5刀/年</code>（折合软妹币52.129；按软妹付款为54多）， 配置如下：</p>\n<table>\n<thead>\n<tr>\n<th>CPU</th>\n<th>RAM</th>\n<th>硬盘</th>\n<th>带宽&#x2F;流量</th>\n<th>IP</th>\n<th>DDoS保护</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1核</td>\n<td>128M</td>\n<td>10G SSD</td>\n<td>1Gbps&#x2F;250Gbp</td>\n<td>一个</td>\n<td>10Gbps</td>\n</tr>\n</tbody></table>\n<p>个人觉得还可以，就买了一个练习配置，因为内存不大，所以打算配置nodejs练练手，就当学习了。下边是linux配置，非购买使用流程。</p>\n<ol>\n<li>根据提供的IP:22使用putty链接</li>\n<li>用户名root 密码***** <img src=\"http://xiaqiubo.top/wp-content/uploads/2017/02/virmach001-300x188.png\"></li>\n<li>该主机自带了python2.7.3 <img src=\"http://xiaqiubo.top/wp-content/uploads/2017/02/virmach002-300x42.png\"></li>\n<li>于是安装node就省去了很大一步（注：还得在本地虚拟机从零测试安装） <code>cd /usr/local/</code> 在这个文件夹下（当然哪个文件夹都可以），下载nodejs资源包 本来想服务器在国外，下载国外的node资源应该不错，</li>\n</ol>\n<ul>\n<li>于是乎找到下载地址（官网的） <a href=\"https://nodejs.org/dist/v6.9.2/node-v6.9.2-linux-x86.tar.xz\">https://nodejs.org/dist/v6.9.2/node-v6.9.2-linux-x86.tar.xz</a> </li>\n<li>运行 <code>wget --no-check-certificate https://nodejs.org/dist/v6.9.2/node-v6.9.2-linux-x86.tar.xz</code> no-check-certificate是阻止wget下载前验证 下载成功 ，而且网速还不错<br><img src=\"http://xiaqiubo.top/wp-content/uploads/2017/02/virmach003-300x188.png\"> </li>\n<li>解压 <code>tar node-v6.9.2-linux-x86.tar.xz</code> (已解决使用xz命令解压缩  2016-12-26) 格式错误。于是只能拐回国内链接 </li>\n<li>同样运行 <code>wget --no-check-certificate https://nodejs.org/dist/v6.2.0/node-v6.2.0-linux-x86.tar.gz</code>          <br><img src=\"http://xiaqiubo.top/wp-content/uploads/2017/02/virmach004-300x189.png\"> 下载成功，网速依旧。</li>\n<li>解压 <code>tar node-v6.9.2-linux-x86.tar.xz</code></li>\n</ul>\n<ol start=\"5\">\n<li>解压文件包并重命名文件夹（详情搜索mv命令） <code>mv node-v6.9.2-linux-x86 node</code></li>\n<li>配置临时环境变量 <code>export PATH=/usr/local/python/bin:/usr/local/node/bin:$PATH</code> 该环境变量为临时变量，关闭ssh窗口即失效 所以需要配置永久环境变量，修改etc&#x2F;profile文件</li>\n<li>编辑添加全局环境变量 <code>vim /etc/profile</code><br>   <img src=\"http://xiaqiubo.top/wp-content/uploads/2017/02/virmach005-300x188.png\"> 增加变量路径 <code>:wq</code>保存退出</li>\n<li>node环境配置成功<br>   <img src=\"http://xiaqiubo.top/wp-content/uploads/2017/02/virmach006-300x48.png\"></li>\n</ol>\n<p>剩下的后期继续更新。</p>\n",
            "tags": [
                "linux",
                "nodejs",
                "虚拟主机"
            ]
        },
        {
            "id": "http://qiubo.ink/2016/12/08/gulp%E5%88%9D%E4%BD%93%E9%AA%8C/",
            "url": "http://qiubo.ink/2016/12/08/gulp%E5%88%9D%E4%BD%93%E9%AA%8C/",
            "title": "gulp初体验",
            "date_published": "2016-12-08T12:09:12.000Z",
            "content_html": "<p>在云IDEcloud9中体验测试了gulp</p>\n<h4 id=\"1-首先npm-install-gulp-g\"><a href=\"#1-首先npm-install-gulp-g\" class=\"headerlink\" title=\"1. 首先npm install gulp -g\"></a>1. 首先npm install gulp -g</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp --save-dev 全局和项目安装gulp</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-测试项目为压缩文件和修改文件名称\"><a href=\"#2-测试项目为压缩文件和修改文件名称\" class=\"headerlink\" title=\"2. 测试项目为压缩文件和修改文件名称\"></a>2. 测试项目为压缩文件和修改文件名称</h4><p>安装gulp依赖项</p>\n<p>| 名称 | 含义 |<br>|gulp-minify|压缩css文件|<br>|gulp-uglify|压缩js文件|<br>|gulp-concat|合并文件|<br>|gulp-rename|修改文件或文件夹名称|</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp-minify --save-dev</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-创建gulpfile-js文件\"><a href=\"#3-创建gulpfile-js文件\" class=\"headerlink\" title=\"3. 创建gulpfile.js文件\"></a>3. 创建gulpfile.js文件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gulp = require(&#x27;gulp&#x27;),</span><br><span class=\"line\">    minify = require(&#x27;gulp-minify&#x27;),</span><br><span class=\"line\">    uglify = require(&#x27;gulp-uglify&#x27;),</span><br><span class=\"line\">    concat = require(&#x27;gulp-concat&#x27;),</span><br><span class=\"line\">    rename = require(&#x27;gulp-rename&#x27;);</span><br><span class=\"line\">//获取每个组件</span><br><span class=\"line\"> gulp.task(&#x27;taskName&#x27;,function()&#123;</span><br><span class=\"line\">    return gulp.src(&#x27;./dst/js/*.js&#x27;)               //返回任务操作路径和文件</span><br><span class=\"line\">        .pipe(concat(&#x27;functions.js&#x27;))              //合并所有的js文件为functions.js</span><br><span class=\"line\">        .pipe(gulp.dest(&#x27;./src/js/&#x27;))              //输出functions.js文件到根目录下src下js文件夹</span><br><span class=\"line\">        .pipe(uglify())                            //压缩该文件</span><br><span class=\"line\">        .pipe(rename(&#123;extname:&#x27;.min.js&#x27;&#125;))         //对压缩后的文件进行重命名，修改文件后缀为.min.js</span><br><span class=\"line\">        .pipe(gulp.dest(&#x27;./src/js/&#x27;));             //输出到与未压缩同目录下</span><br><span class=\"line\"> &#125;);//新建一个名字叫taskName的任务</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-文件内容详解：\"><a href=\"#4-文件内容详解：\" class=\"headerlink\" title=\"4. 文件内容详解：\"></a>4. 文件内容详解：</h4><h5 id=\"require-函数：\"><a href=\"#require-函数：\" class=\"headerlink\" title=\"require()函数：\"></a>require()函数：</h5><p>参数为string<br><strong>1. 如果string为内置模块</strong><br>        返回该模块 不再继续执行<br><strong>2. 如果string以文件路径形式（如：’.&#x2F;X’、’..&#x2F;X’ 、’&#x2F;X’）</strong><br>        根据 X 所在的父模块，确定 X 的绝对路径。 将 X 当成文件，依次查找名称为X的文件，只要其中有一个存在，就返回该文件，不再继续执行。 X X.js X.json X.node 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。 X&#x2F;package.json X&#x2F;index.js X&#x2F;index.json X&#x2F;index.node<br><strong>3. 如果string不带路径</strong><br>        根据 X 所在的父模块，确定 X 可能的安装目录。 依次在每个目录中，将 X 当成文件名或目录名加载。<br>        <a href=\"http://www.ruanyifeng.com/blog/2015/05/require.html\">参考文章1</a><br>        <a href=\"http://www.jdon.com/idea/nodejs/how-require-actually-works.html\">参考文章2</a></p>\n<h5 id=\"gulp-task\"><a href=\"#gulp-task\" class=\"headerlink\" title=\"gulp.task()\"></a>gulp.task()</h5><p>用于创建gulp任务，默认任务名称为<code>default task(&#39;a&#39;,b)</code>; 参数a：指定任务名称 参数b：匿名函数 执行任务时运行 gulp a（默认任务名直接执行 gulp 即可）</p>\n<h5 id=\"gulp-src\"><a href=\"#gulp-src\" class=\"headerlink\" title=\"gulp.src()\"></a>gulp.src()</h5><pre><code>    `gulp.src(globs[, options])`\n    1. `globs` 参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组。\n    2. `options` 为可选参数。通常情况下我们不需要用到。\n</code></pre>\n<h5 id=\"pipe\"><a href=\"#pipe\" class=\"headerlink\" title=\"pipe()\"></a>pipe()</h5><p><code>node.js</code> 中 <code>stream</code>（流）的指示方向</p>\n<h5 id=\"gulp-dest\"><a href=\"#gulp-dest\" class=\"headerlink\" title=\"gulp.dest()\"></a>gulp.dest()</h5><p><code>gulp.dest()</code> 方法是用来写文件的，其语法为：</p>\n<pre><code>    `gulp.dest(path[,options])`\n    1. path为写入文件的路径\n    2. options为一个可选的参数对象，通常我们不需要用到\n</code></pre>\n<h5 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat()\"></a>concat()</h5><p>合并文件，指定参数为合并后的文件名称</p>\n<h5 id=\"uglify\"><a href=\"#uglify\" class=\"headerlink\" title=\"uglify()\"></a>uglify()</h5><p>压缩文件，没有制定参数，直接压缩js文件</p>\n<h5 id=\"rename\"><a href=\"#rename\" class=\"headerlink\" title=\"rename()\"></a>rename()</h5><p>参数为数组，<code>basename</code>、<code>prefix/suffix</code>、<code>extname</code>、<code>dirname</code> 常用：prefix: ‘pre-‘ 增加前缀pre- suffix: ‘-suf’ 增加后缀，不改变文件性质 extname:’.min.js’ 修改文件后缀 <a href=\"http://www.cnblogs.com/2050/p/4198792.html\">参考文章3</a></p>\n",
            "tags": [
                "nodejs",
                "gulp",
                "前端自动化"
            ]
        }
    ]
}